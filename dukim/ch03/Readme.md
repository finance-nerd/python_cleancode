# Chapter 3_좋은 코드의 일반적인 특징
- 목표
    - 견고한 소프트웨어의 개념을 이해
    - 작업 중 잘못된 데이터를 다루는 방법
    - 새로운 요구 사항을 쉽게 받아들이고 확장할 수 잇는 유지보수가 쉬운 소프트웨어 설계
    - 재사용 가능한 소프트웨어 설계
    - 개발팀의 생산성을 높이는 효율적인 코드 작성
    
### 계약에 의한 디자인
- 소프트웨어는 사용자가 직접 호출하거나 
- 코드의 다른 부분에서 호출함
    - 레이어나 컴포넌트로 분리한 경우
- 컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용한 고객에게는 API를 노출해야 함
- 계약에 의한 디자인(Design by Contract)
    - 코드가 정상적으로 동작하는 것과 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 함
    - 모든 당사자가 기대하는 것을 암묵적으로 코드에 배치하는 대신 
    - 위반시 예외를 제기하고 왜 계속할 수 없는지 명확하게 명시한 계약에 동의
    - 계약이란 반드시 지켜져야 할 규칙을 강제하는 것
    - 사전조건(precondition)
        - 코드가 실행되 전에 체크해야 하는 것들
    - 사후조건(postcondition)
        - 함수 반환값의 유효성 검사가 수행
    - 불변식(invariant)
        - 함수의 docstring에 불변식에 대해 문서화하는 것이 좋음
    - 부작용(side-effect)
        - 부작용을 docstring에 언급
    - 사전조건과 사후조건은 코드레벨에서 강제
#### 사전조건(precondition)
- 필요로 하는 값이 정확한지 확인하는 것
- 관용적인(tolerant) 접근법
    - 클라이언트가 함수 호출하기 전에 모든 유효성 검사
    - 함수가 어떤 값이라도 허용
- 까다로운(demanding) 접근법
    - 함수가 자체적으로 로직을 실행하기 전에 검사
- 사전조건 검증을 클라이언트와 함수내 양쪽에서 하지 말고 오직 한쪽에서 진행해야 함
#### 사후조건(postcondition)
- 반환된 후의 상태를 강제하는 계약의 일부
#### 파이썬스러운 계약
- 메서드, 함수 및 클래스에 RuntimeError, ValueError 예외를 발생시키는 제어 메커니즘 추가
#### 계약에 의한 디자인(DbC) - 결론
- 문제가 있는 부분을 효과적으로 식별
- 프로그램 구조를 명확히 하는 목적으로 사용
    - 함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지 정의
- 무엇을 검증할 것인지 신중히 검토
    - 함수에 전달되는 객체의 속성과 반환 값을 검사
    - 유지해야 하는 조건을 확인하는 작업 필요
 
### 방어적(defensive) 프로그래밍
- 계약에서 예외를 발생시키고 실해하게 되는 모든 조건을 기술하는 대신
- 객체, 함수 또는 메서드와 같은 코드의 모든 부분을 유효하지 않은 것으로부터 보호
- DbC와 서로 보완 관계
- 예상할 수 있는 시나리오의 오류를 처리하는 방법
    - 에러 핸들링 프로시저
- 발생하지 않아야 하는 오류를 처리하는 방법
    - 어썰션(assertion)
#### 에러 핸들링
- 예상되는 에러에 대해서 실행을 계속할지 중단할지 결정하는 것
- 에러 처리 방법
    - 값 대체(substitution)
        - 견고성과 정확성 간의 트레이드오프
        ``` 
        configuration = {"dbport": 5432}
        configuration .get("dbhost": "localhost")
        ```
        - 값 대체하는 것은 오류를 숨겨버릴 수 있으므로 주의해서 사용해야 함 
    - 에러 로깅
    - 예외 처리
        - 예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것
- 예외는 호출자에게 잘못을 알려주는 것
    - 캡슐화를 약화시키기 때문에 신중하게 사용
- 함수가 너무 많은 예외를 발생시키는 경우
    - 응집력이 약함
    - 많은 책임을 갖고 있음
    - 여러 개의 작은 것으로 나누는 것도 고려
- 예외 리펙토링
    - 올바른 수준의 추상화 단계에서 예외 처리
        - [리펙토링이 필요한 코드](errorhandling1.py)
        - [리펙토링 후 코드](errorhandling2.py)
    - Traceback 노출 금지
        - 오류가 너무 중요하다면 전파해도 됨
        - 정확성이 중요한 상황이라면 프로그램을 종료할 수 있음
        - traceback 정보, 메시지, 기타 수집 가능한 정보를 로그로 남기는 것이 중요
        - 세부사항은 절대 사용자에게 보여서는 안됨
        - 사용자에게 알리려면 일반적인 메시지를 사용
    - 비어있는 except 블록 지양
        - 가장 안 좋은 예
            ``` 
            try:
                process_data()
            except:
                pass
            ```
    - 원본 예외 포함
        - 오류 처리시 메시지를 변경할 경우에는 원본 메시지를 포함하는 것이 좋음
        - ```raise <e> from <original_exception>``` 구문 사용
            ``` 
            class InternalDataError(Exception):
                def process(data_dictionary, record_id):
                    try:
                        return data_dictionary[record_id]
                    exception KeyError as e:
                        raise InternalDataError("Record not present") from e
            ```    
#### 파이썬에서 어설션 사용하기
- 절대로 일어나지 않아야 하는 상황
- assert 문에 사용된 표현식은 불가능한 조건을 의미
- 비지니스 로직과 섞어나 소프트웨어의 제어 흐름 메커니즘으로 사용해서는 안됨
    ``` 
    try:
        assert condition.holds(), "조건에 맞지 않음."
    except AssertionError:
        alternative_procedure()
    ``` 
    - 어설션 문장이 함수인것도 나쁜 코드
    ``` 
    result= condition.holds()
    assert result > 0, "에러 {0}".format(result)
    ```
### 관심사의 분리
#### 응집력(cohesion)과 결합력(coupling)
### 개발 지침 약어
#### DRY/OAOO
#### YAGNI
#### KIS
#### EAFP/LBYL
### 컴포지션과 상속
#### 상속이 좋은 선택인 경우
#### 상속 안티패턴
#### 파이썬의 다중상속
### 함수와 메서드의 인자
#### 파이썬의 함수 인자 동작 방식
#### 함수 인자의 개수
### 소프트웨어 디자인 우수 사례 결론
#### 소프트웨어의 독립성(orthogonality)
#### 코드 구조
### 요약

